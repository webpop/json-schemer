// Generated by CoffeeScript 1.3.3
(function() {

  describe("JsonSchema", function() {
    describe("with a simple example schema from the ietf draft", function() {
      beforeEach(function() {
        return this.schema = new JsonSchema({
          description: "A person",
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            age: {
              type: "integer",
              maximum: 125
            }
          }
        });
      });
      it("should process an empty object", function() {
        return runs(function() {
          var _this = this;
          return this.schema.process({}, function(err, result) {
            console.log("Got %o", result);
            expect(Object.keys(result.doc)).toEqual(['name', 'age']);
            expect(result.doc.name).toBe(void 0);
            expect(result.doc.age).toBe(void 0);
            return expect(result.valid).toBe(true);
          });
        });
      });
      it("should process a valid object", function() {
        return runs(function() {
          var _this = this;
          return this.schema.process({
            name: "Mathias",
            age: 35
          }, function(err, result) {
            expect(Object.keys(result.doc)).toEqual(["name", "age"]);
            expect(result.doc.name).toEqual("Mathias");
            expect(result.doc.age).toEqual(35);
            return expect(result.valid).toBe(true);
          });
        });
      });
      it("should cast strings to numbers where needed", function() {
        return runs(function() {
          var _this = this;
          return this.schema.process({
            age: "35"
          }, function(err, result) {
            expect(result.doc.age).toEqual(35);
            return expect(result.valid).toBe(true);
          });
        });
      });
      it("should validate the maximum for a number", function() {
        return runs(function() {
          var _this = this;
          return this.schema.process({
            age: 200
          }, function(err, result) {
            expect(result.doc.age).toEqual(200);
            expect(result.valid).toBe(false);
            return expect(result.errors.all()).toEqual([["age", ["maximum"]]]);
          });
        });
      });
      return it("should use a default value", function() {
        this.schema.properties.name["default"] = "Default";
        return runs(function() {
          var _this = this;
          return this.schema.process({}, function(err, result) {
            return expect(result.doc.name).toEqual("Default");
          });
        });
      });
    });
    describe("validations", function() {
      describe("optional and required fields", function() {
        beforeEach(function() {
          return this.schema = new JsonSchema({
            type: "object",
            properties: {
              optional: {
                type: "string"
              },
              required: {
                type: "string",
                required: true
              }
            }
          });
        });
        return it("should validate required fields", function() {
          return runs(function() {
            var _this = this;
            return this.schema.process({}, function(err, result) {
              expect(result.valid).toBe(false);
              expect(result.errors.on("optional")).toBe(void 0);
              return expect(result.errors.on("required")).toEqual(["required"]);
            });
          });
        });
      });
      describe("string validations", function() {
        beforeEach(function() {
          return this.schema = new JsonSchema({
            type: "object",
            properties: {
              minlength: {
                type: "string",
                minLength: 1
              },
              maxlength: {
                type: "string",
                maxLength: 2
              },
              pattern: {
                type: "string",
                pattern: "^[a-z]+$"
              },
              "enum": {
                type: "string",
                "enum": ["one", "two", "three"]
              }
            }
          });
        });
        it("should validate the minLength", function() {
          runs(function() {
            var _this = this;
            return this.schema.process({
              minlength: ""
            }, function(err, result) {
              expect(result.valid).toBe(false);
              return expect(result.errors.on("minlength")).toEqual(["minLength"]);
            });
          });
          return runs(function() {
            var _this = this;
            return this.schema.process({
              minlength: "good"
            }, function(err, result) {
              return expect(result.valid).toBe(true);
            });
          });
        });
        it("should validate the maxLength", function() {
          runs(function() {
            var _this = this;
            return this.schema.process({
              maxlength: "hello"
            }, function(err, result) {
              expect(result.valid).toBe(false);
              return expect(result.errors.on("maxlength")).toEqual(["maxLength"]);
            });
          });
          return runs(function() {
            var _this = this;
            return this.schema.process({
              maxlength: "It"
            }, function(err, result) {
              return expect(result.valid).toBe(true);
            });
          });
        });
        it("should validate the pattern", function() {
          runs(function() {
            var _this = this;
            return this.schema.process({
              pattern: "Has Spaces"
            }, function(err, result) {
              expect(result.valid).toBe(false);
              return expect(result.errors.on("pattern")).toEqual(["pattern"]);
            });
          });
          return runs(function() {
            var _this = this;
            return this.schema.process({
              pattern: "nospaces"
            }, function(err, result) {
              return expect(result.valid).toBe(true);
            });
          });
        });
        return it("should validate the enum", function() {
          runs(function() {
            var _this = this;
            return this.schema.process({
              "enum": "four"
            }, function(err, result) {
              expect(result.valid).toBe(false);
              return expect(result.errors.on("enum")).toEqual(["enum"]);
            });
          });
          return runs(function() {
            var _this = this;
            return this.schema.process({
              "enum": "two"
            }, function(err, result) {
              return expect(result.valid).toBe(true);
            });
          });
        });
      });
      describe("date and time", function() {
        beforeEach(function() {
          return this.schema = new JsonSchema({
            type: "object",
            properties: {
              datetime: {
                type: "string",
                format: "date-time"
              },
              date: {
                type: "string",
                format: "date"
              }
            }
          });
        });
        it("should process a date", function() {
          return runs(function() {
            var _this = this;
            return this.schema.process({
              date: "2012-07-09"
            }, function(err, result) {
              return expect(result.doc.date.getFullYear()).toEqual(2012);
            });
          });
        });
        it("should process a date-time", function() {
          return runs(function() {
            var _this = this;
            return this.schema.process({
              datetime: "2012-07-09T12:09:18Z"
            }, function(err, result) {
              return expect(result.doc.datetime.getFullYear()).toEqual(2012);
            });
          });
        });
        return it("should validate a date", function() {
          return runs(function() {
            var _this = this;
            return this.schema.process({
              date: "09/09/2012"
            }, function(err, result) {
              expect(result.valid).toBe(false);
              return expect(result.errors.on("date")).toEqual(["format"]);
            });
          });
        });
      });
      return describe("number validations", function() {
        beforeEach(function() {
          return this.schema = new JsonSchema({
            type: "object",
            properties: {
              number: {
                type: "integer",
                minimum: 10,
                maximum: 50,
                divisibleBy: 10
              }
            }
          });
        });
        it("should not validate an empty value", function() {
          return runs(function() {
            var _this = this;
            return this.schema.process({
              divisibleBy: ""
            }, function(err, result) {
              return expect(result.valid).toBe(true);
            });
          });
        });
        it("should validate maximum", function() {
          return runs(function() {
            var _this = this;
            return this.schema.process({
              number: 100
            }, function(err, result) {
              expect(result.valid).toBe(false);
              return expect(result.errors.on("number")).toEqual(["maximum"]);
            });
          });
        });
        it("should accept a value equal to maximum", function() {
          return runs(function() {
            var _this = this;
            return this.schema.process({
              number: 50
            }, function(err, result) {
              return expect(result.valid).toBe(true);
            });
          });
        });
        it("should validate minimum", function() {
          return runs(function() {
            var _this = this;
            return this.schema.process({
              number: 0
            }, function(err, result) {
              expect(result.valid).toBe(false);
              return expect(result.errors.on("number")).toEqual(["minimum"]);
            });
          });
        });
        it("should accept a value equal to minimum", function() {
          return runs(function() {
            var _this = this;
            return this.schema.process({
              number: 10
            }, function(err, result) {
              return expect(result.valid).toBe(true);
            });
          });
        });
        it("should validate divisibleBy", function() {
          return runs(function() {
            var _this = this;
            return this.schema.process({
              number: 35
            }, function(err, result) {
              expect(result.valid).toBe(false);
              return expect(result.errors.on("number")).toEqual(["divisibleBy"]);
            });
          });
        });
        it("should validate both divisibleBy and minimum", function() {
          return runs(function() {
            var _this = this;
            return this.schema.process({
              number: 5
            }, function(err, result) {
              expect(result.valid).toBe(false);
              return expect(result.errors.on("number")).toEqual(["minimum", "divisibleBy"]);
            });
          });
        });
        it("should handle excludeMinimum", function() {
          this.schema.properties.number.excludeMinimum = true;
          runs(function() {
            return this.schema.process({
              number: 20
            }, function(err, result) {
              return expect(result.valid).toBe(true);
            });
          });
          runs(function() {
            return this.schema.process({
              number: 10
            }, function(err, result) {
              return expect(result.valid).toBe(false);
            });
          });
          return runs(function() {
            return this.schema.process({
              number: 10
            }, function(err, result) {
              return expect(result.errors.on("number")).toEqual(["minimum"]);
            });
          });
        });
        return it("should handle excludeMaximum", function() {
          this.schema.properties.number.excludeMaximum = true;
          runs(function() {
            return this.schema.process({
              number: 20
            }, function(err, result) {
              return expect(result.valid).toBe(true);
            });
          });
          runs(function() {
            return this.schema.process({
              number: 50
            }, function(err, result) {
              return expect(result.valid).toBe(false);
            });
          });
          return runs(function() {
            return this.schema.process({
              number: 50
            }, function(err, result) {
              return expect(result.errors.on("number")).toEqual(["maximum"]);
            });
          });
        });
      });
    });
    describe("arrays", function() {
      beforeEach(function() {
        return this.schema = new JsonSchema({
          type: "object",
          properties: {
            array: {
              type: "array"
            }
          }
        });
      });
      it("should handle array values", function() {
        return runs(function() {
          var _this = this;
          return this.schema.process({
            array: [1, "2", 3]
          }, function(err, result) {
            expect(result.valid).toBe(true);
            return expect(result.doc.array).toEqual([1, "2", 3]);
          });
        });
      });
      it("should validate minItems", function() {
        this.schema.properties.array.minItems = 3;
        runs(function() {
          var _this = this;
          return this.schema.process({
            array: [1, 2]
          }, function(err, result) {
            expect(result.valid).toBe(false);
            return expect(result.errors.on("array")).toEqual(["minItems"]);
          });
        });
        return runs(function() {
          var _this = this;
          return this.schema.process({
            array: [1, 2, 3]
          }, function(err, result) {
            return expect(result.valid).toBe(true);
          });
        });
      });
      it("should validate maxItems", function() {
        this.schema.properties.array.maxItems = 3;
        runs(function() {
          var _this = this;
          return this.schema.process({
            array: [1, 2, 3, 4]
          }, function(err, result) {
            expect(result.valid).toBe(false);
            return expect(result.errors.on("array")).toEqual(["maxItems"]);
          });
        });
        return runs(function() {
          var _this = this;
          return this.schema.process({
            array: [1, 2, 3]
          }, function(err, result) {
            return expect(result.valid).toBe(true);
          });
        });
      });
      return describe("with numerical items", function() {
        beforeEach(function() {
          return this.schema.properties.array.items = {
            type: "integer"
          };
        });
        it("should cast array values", function() {
          console.log("Should cast array values");
          return runs(function() {
            var _this = this;
            return this.schema.process({
              array: ["1", "2", "3"]
            }, function(err, result) {
              expect(result.valid).toBe(true);
              return expect(result.doc.array).toEqual([1, 2, 3]);
            });
          });
        });
        return it("should validate array values", function() {
          this.schema.properties.array.items.minimum = 3;
          return runs(function() {
            var _this = this;
            return this.schema.process({
              array: [1, 2, 3]
            }, function(err, result) {
              expect(result.valid).toBe(false);
              expect(result.errors.on("array.0")).toEqual(["minimum"]);
              expect(result.errors.on("array.1")).toEqual(["minimum"]);
              return expect(result.errors.on("array.2")).toBe(void 0);
            });
          });
        });
      });
    });
    describe("objects", function() {
      beforeEach(function() {
        return this.schema = new JsonSchema({
          type: "object",
          properties: {
            object: {
              type: "object",
              properties: {
                test: {
                  type: "string"
                }
              }
            }
          }
        });
      });
      it("should process an object", function() {
        return runs(function() {
          var _this = this;
          return this.schema.process({
            object: {
              test: "Hello"
            }
          }, function(err, result) {
            return expect(result.doc.object.test).toEqual("Hello");
          });
        });
      });
      it("should validate properties on the object", function() {
        this.schema.properties.object.properties.test.minLength = 8;
        return runs(function() {
          var _this = this;
          return this.schema.process({
            object: {
              test: "Hello"
            }
          }, function(err, result) {
            expect(result.valid).toBe(false);
            return expect(result.errors.on("object.test")).toEqual(["minLength"]);
          });
        });
      });
      return it("should not make the object required when an property is required", function() {
        this.schema.properties.object.properties.test.required = true;
        return runs(function() {
          var _this = this;
          return this.schema.process({}, function(err, result) {
            return expect(result.valid).toBe(true);
          });
        });
      });
    });
    return describe("resolving refs", function() {
      beforeEach(function() {
        var schemas;
        schemas = {
          person: {
            type: "object",
            properties: {
              name: {
                type: "string",
                required: true
              }
            }
          },
          party: {
            type: "object",
            properties: {
              host: {
                type: "object",
                properties: {
                  "$ref": "person#.properties"
                }
              },
              guests: {
                type: "array",
                items: {
                  "$ref": "person"
                }
              }
            }
          }
        };
        JsonSchema.resolver = function(uri, current, cb) {
          var attr;
          attr = schemas[uri];
          if (attr) {
            return cb(null, new JsonSchema(attr));
          } else {
            return cb();
          }
        };
        return this.schema = new JsonSchema(schemas["party"]);
      });
      it("should resolve an object reference", function() {
        runs(function() {
          var _this = this;
          return this.schema.process({
            host: {
              name: "Mathias"
            }
          }, function(err, result) {
            expect(result.doc.host.name).toEqual("Mathias");
            return expect(result.valid).toBe(true);
          });
        });
        return runs(function() {
          var _this = this;
          return this.schema.process({
            host: {}
          }, function(err, result) {
            expect(result.valid).toBe(false);
            return expect(result.errors.on("host.name")).toEqual(["required"]);
          });
        });
      });
      return it("should resolve array references", function() {
        runs(function() {
          var _this = this;
          return this.schema.process({
            guests: [
              {
                name: "Irene"
              }, {
                name: "Julio"
              }
            ]
          }, function(err, result) {
            expect(result.doc.guests[0].name).toEqual("Irene");
            return expect(result.doc.guests[1].name).toEqual("Julio");
          });
        });
        return runs(function() {
          var _this = this;
          return this.schema.process({
            guests: [
              {
                name: "Irene"
              }, {}
            ]
          }, function(err, result) {
            expect(result.valid).toBe(false);
            return expect(result.errors.on("guests.1.name")).toEqual(["required"]);
          });
        });
      });
    });
  });

  describe("JsonErrors", function() {
    return it("should handle merging nested error objects", function() {
      var arrayErrors, errors;
      errors = new JsonErrors;
      errors.add("required");
      arrayErrors = new JsonErrors;
      arrayErrors.add("minItems");
      arrayErrors.add("0", "numeric");
      errors.add("array", arrayErrors);
      expect(errors.on("")).toEqual(["required"]);
      expect(errors.on("array")).toEqual(["minItems"]);
      return expect(errors.on("array.0")).toEqual(["numeric"]);
    });
  });

}).call(this);
